
# システムデザインで学ぶ！検索オートコンプリートの設計と実装

## はじめに

検索オートコンプリートは、現代のWebサービスに欠かせない体験価値を生み出す重要な機能です。
ユーザーが文字を入力するたびに、瞬時に候補を提示することで、検索体験を大きく向上させます。

本記事では「なぜこの構成なのか」「どんな設計思想で作るのか」にフォーカスし、Next.js + Flask + MySQL で作る検索オートコンプリートシステムのシステムデザインを、できるだけ日本語で丁寧に解説します。

---


## システム全体像と設計思想

### アーキテクチャ概要

本システムは、フロントエンド（Next.js）、APIサーバ（Flask）、データベース（MySQL）というシンプルかつ拡張性の高い3層構成です。

```
┌─────────────┐    HTTP     ┌─────────────┐    SQL     ┌─────────────┐
│   Next.js   │ ◄────────► │    Flask    │ ◄───────► │    MySQL    │
│ (Frontend)  │   API Call  │ (Backend)   │   Query    │ (Database)  │
└─────────────┘             └─────────────┘            └─────────────┘
```

#### 設計のポイント
- **責務分離**：UI・API・データの役割を明確に分離し、保守性・拡張性を高めます。
- **シンプルな構成**：まずは最小構成で始め、将来的なキャッシュや全文検索エンジンの追加も容易です。
- **Docker Compose活用**：開発・検証・本番移行まで一貫した環境を素早く構築できます。

### 技術選定理由

- **Next.js**：ReactベースでSSR/SSGも可能。UIの柔軟性と高速な開発体験。
- **Flask**：Python製の軽量Webフレームワーク。API設計がシンプルで学習コストも低い。
- **MySQL**：実績豊富なRDB。インデックスやクエリチューニングで十分なパフォーマンスが出せる。

---


## データ設計と検索体験の工夫

### テーブル設計

検索候補・人気ワード・履歴を効率よく扱うため、以下のようなテーブル設計とインデックスを用意します。

- `search_terms` テーブルは、検索候補の管理と人気度順ソートに最適化。
- `search_history` でユーザーごとの履歴や人気語集計も可能。
- 適切なインデックス設計で、検索時のレスポンスを高速化。

---


## API設計とキャッシュ戦略

### API設計の考え方

APIは「シンプル・高速・拡張性」を重視して設計します。

- `/api/search`：前方一致で候補を返す。クエリパラメータで柔軟に制御。
- `/api/popular`：人気ワードを返す。ランキングやトレンド分析にも応用可能。

### キャッシュ戦略

実運用ではRedis等のインメモリキャッシュを挟むことで、「よく使われる検索語」や「人気ワード」を高速に返せます。

---

## セキュリティ・監視・運用のポイント

- SQLインジェクション対策は必須。パラメータ化クエリを徹底
- サービス間通信は環境変数で管理し、認証情報のハードコーディングを避ける
- APIのレスポンス時間やエラー率をログ出力し、遅延や障害を早期検知
- アクセスログ・検索クエリログを構造化してBI分析にも活用

---

## 発展系: コスト最適かつ低レイテンシを実現する実運用アーキテクチャ

ここでは `infrastructure.md` の内容を実務で使いやすい形に整理し、設計者・実装者が具体的に判断・実装できるように要点をまとめます。

### 全体像（一言）
- 目的: P95 < 200ms / 月額コスト < $150 を目標に、マネージドサービスと多層キャッシュで最小構成から段階拡張する。

### 推奨アーキテクチャ（簡易図）
```
User
	│
	├─→ CloudFront ──→ S3 (静的)
	│
	└─→ ALB ──→ ECS(Fargate) API
								 ├─→ Redis (ElastiCache)
								 ├─→ OpenSearch
								 └─→ RDS (MySQL)
```

### コンポーネント要約（運用上の判断点）
- CloudFront+S3: 静的配信とEdgeキャッシュでフロントの負荷を抑える。/api/popular のEdge TTLを設定。
- ALB + ECS(Fargate): 最小は2タスク。CPUしきい値で水平スケール。タスクサイズは低コスト前提で小さく始める。
- Redis: 第一応答レイヤ。小さなノードで始めてメトリクス（CacheHitRate, Evictions）を見て増強。
- OpenSearch: 候補生成と重い検索のエンジン。キャッシュヒットで負荷を抑える。
- RDS(MySQL): 正本データとログ保持に限定。インデックス設計で検索負荷を避ける。

### 実用的キャッシュポリシー（即使える定義）
- Browser: 検索結果 60s / 人気ワード 300s
- CloudFront: `/api/popular` Edge TTL 300s、`/api/search` はパススルー
- Redis keys: `search:{query}` TTL=600s、`popular:all` TTL=3600s、`user:history:{user_id}` TTL=300s
- OpenSearch: クエリ結果のローカルキャッシュ（同一クエリ < 10分）を検討

### SLO と計測（必須メトリクス）
- /api/search: P95 < 200ms（目標）。期待する構成: Redisヒット率 ≈ 80%。
- /api/popular: P95 < 100ms（高キャッシュヒット）。
- 監視: API latency, error rate, Redis CacheHitRate, OpenSearch latency, RDS connections, ECS CPU/RPS。

### スケール戦略（段階的）
- 小規模: 単一AZ・小ノードで開始（コスト最優先）。監視でしきい値超過時に拡張。
- 水平: ECSタスク数増加 → OpenSearchノード追加 → Redisノードクラス上げ（クラス変更）
- 垂直: t3.small/medium へサイズアップ（まずは垂直、次に水平）

### 可用性・DR（現実的な妥協案）
- RPO: 24h、RTO: <4h を目安にする（検索候補は再構築可能なため許容）。
- RDS: 自動バックアップ & PITR、OpenSearch: 日次スナップショットをS3へ保存。
- Redis: 必要ならレプリケーションやAOF、有効な再生成スクリプトで復旧を短縮。

### セキュリティと運用の具体策
- VPC分離: Public(Alb) / Private(ECS, Redis, OpenSearch, RDS)
- IAM最小権限・Secrets ManagerでDSN/鍵を管理
- 暗号化: in-transit TLS と at-rest の設定を標準化
- WAF, 基本ルールで外部の悪性リクエストをブロック

### 実装“契約”（Inputs / Outputs / 成功基準）
- Inputs: user query (q), user id (optional), feature flags for ranking
- Outputs: JSON array of candidate strings + metadata (source: cache/OS/DB, latency)
- 成功基準: 1) P95 レイテンシ要件を満たす 2) キャッシュヒット率が想定レンジ内 3) エラー率 < 0.1%

### 代表的なエッジケース
- 空クエリ/短すぎるクエリ（サーバ負荷低減のためローカルで早期返却）
- 高頻度更新（人気語の再集計とキャッシュ失効の整合）
- キャッシュスパイク（キャッシュミス連発時のバックプレッシャ対策）

### 次のステップ（短期で価値が出る実作業）
1. Redisキャッシュ設計を実装し、CacheHitRateをダッシュボード化
2. `/api/popular` をCloudFront Edgeでキャッシュして静的化
3. 負荷の小さい段階でOpenSearchの導入を検証（クエリプロファイル取得）

---



## まとめ

検索オートコンプリートは「速さ」と「使いやすさ」が命です。そのためには、

- シンプルな3層構成で責務を分離
- 適切なインデックス・キャッシュ戦略で高速化
- スケールアウト・運用性・セキュリティも意識

といったシステムデザインの基本を押さえることが重要です。

本記事の構成をベースに、RedisやElasticsearchなどの導入・クラウド化・監視自動化など、さらに高度なシステムへ発展させていくことも可能です。

