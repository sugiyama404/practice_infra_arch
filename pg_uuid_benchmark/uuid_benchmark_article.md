# データベースID生成方式の性能比較: 複数DB比較 (PostgreSQL, MySQL, Redis, MongoDB, SQLite)

## 概要

この記事では、PostgreSQL, MySQL, Redis, MongoDB, SQLiteを対象としたID生成方式（Auto-increment, UUID v4, UUID v7, Snowflake）のCRUD操作性能を比較したベンチマーク結果を解説します。データベースのスケーラビリティと分散性を考慮したID選択の指針を提供することを目的としています。

**注意**: このベンチマークではPostgreSQL 18を使用していますが、データシードの制約により、PostgreSQLの結果はUUID v4およびUUID v7のみを対象としています。Auto-incrementおよびSnowflakeの結果はMySQLから引用しています。

## 背景

現代の分散システムでは、一意なID生成が重要な課題です。従来のAuto-incrementは単一DBでは効率的ですが、分散環境では不向きです。一方、UUID v4は分散性に優れますが、性能面で課題があります。UUID v7やSnowflakeのような時間順序性を考慮した方式が注目されています。

このベンチマークでは、以下のID生成方式を比較：
- **Auto-increment**: シーケンシャルな整数ID（MySQLのみ）
- **UUID v4**: ランダムな128ビットUUID
- **UUID v7**: 時間順序性を考慮したUUID
- **Snowflake**: Twitterの分散ID生成アルゴリズム（MySQLのみ）

## ベンチマーク設定

### 環境
- **データベース**:
  - PostgreSQL 17 (postgres_mixed) - 全ID方式比較用
  - MySQL 8.3
  - Redis 7
  - MongoDB 7
  - SQLite (keinos/sqlite3:latest)
- **ストレージ**: ローカルNVMe SSD
- **ワークロード**: 挿入、更新、削除、選択操作
- **データ規模**: 数万〜数十万行
- **並行性**: 複数スレッドでの同時実行

### 測定項目
- **挿入スループット**: 1秒間に挿入できるレコード数
- **CRUD操作レイテンシ**: 各操作の応答時間
- **範囲SELECT分布**: レンジクエリの効率性
- **テーブル/インデックスサイズ**: ストレージ使用量
- **インデックス断片化**: インデックスの効率性

## 結果と考察

### PostgreSQL（UUID v4およびv7のみ）

#### 挿入スループット
UUID v7がUUID v4よりも高いスループットを示しました。UUID v7の時間順序性により、B-Treeのページ分割が減少し、挿入効率が向上します。

| ID方式 | 相対スループット | 特徴 |
|--------|------------------|------|
| UUID v7 | 高 | 時間順序性による効率的な挿入 |
| UUID v4 | 低 | ランダム性によるページ分割増加 |

#### CRUDレイテンシ
主キー検索では両方式で差が小さいですが、INSERT操作ではUUID v4のレイテンシが高くなります。UUID v7はシーケンシャルな挿入が可能で、性能が安定します。

#### 範囲SELECT分布
UUID v7は時間順序性があるため、レンジスキャン時の分布が比較的滑らかです。一方、UUID v4はランダム性が高く、アクセス分布にばらつきが生じます。

#### サイズ比較
UUIDは128ビット（16バイト）で、bigint（8バイト）のAuto-incrementよりもサイズが大きいです。UUID v4は断片化の影響で、実効サイズが増加する傾向があります。

### MySQL

#### 挿入スループット
Auto-incrementが最も高いスループットを示し、UUID v7とSnowflakeがこれに次ぐ。UUID v4は顕著に低い性能を示しました。InnoDBのクラスタ化インデックス特性により、シーケンシャルIDが優位です。

| ID方式 | 相対スループット | 特徴 |
|--------|------------------|------|
| Auto-increment | 最高 | シーケンシャル挿入で最高性能 |
| UUID v7 | 高 | Snowflakeと同等、Auto-incrementに次ぐ |
| Snowflake | 高 | 分散性と性能のバランス |
| UUID v4 | 低 | ランダム性による性能低下 |

#### CRUDレイテンシ
主キー検索は全方式で高速ですが、INSERTではUUID v4が高止まり。UUID v7とSnowflakeはAuto-incrementに近い性能を発揮します。

#### 範囲SELECT分布
Auto-incrementとUUID v7はレンジアクセス時のばらつきが小さく、効率的です。UUID v4はコストのばらつきが大きく、アクセス効率が低下します。

#### サイズ比較
bigint（Auto-increment）が最小サイズ。UUIDはインデックス/テーブル占有が増加、特にUUID v4の断片化影響が顕著です。

| ID方式 | サイズ（PK） | 特徴 |
|--------|--------------|------|
| Auto-increment (bigint) | 8バイト | 最小サイズ |
| UUID (v4/v7) | 16バイト | サイズ増加、断片化影響 |
| Snowflake | 8バイト | 整数ベースでコンパクト |

### Redis

RedisはインメモリKVSとして、高速なCRUD操作を提供します。ID生成方式による性能差は小さく、主にデータ構造の選択が影響します。

#### 挿入スループット
全ID方式で高いスループットを示します。メモリベースのため、ディスクI/Oのボトルネックがありません。

#### CRUDレイテンシ
主キー検索が極めて高速。INSERT/UPDATEも低レイテンシですが、複雑なクエリはサポートされません。

#### 範囲SELECT分布
Redisはレンジクエリをサポートしますが、ソートセットを使用する場合に効率的です。

#### サイズ比較
メモリ使用量はデータ量に比例。UUIDのサイズ増加がメモリ消費に影響します。

### MongoDB

MongoDBはドキュメント指向DBとして、柔軟なスキーマを提供します。ID生成方式による性能差はインデックス設計に依存します。

#### 挿入スループット
ObjectId（デフォルト）やUUID v4/v7で安定した性能。Auto-incrementは手動実装が必要。

#### CRUDレイテンシ
主キー検索が高速。INSERTはドキュメントサイズに依存。

#### 範囲SELECT分布
インデックスを使用したレンジクエリが可能。UUID v4のランダム性はインデックス効率に影響。

#### サイズ比較
ドキュメントサイズが増加。UUIDは追加のストレージ消費。

### SQLite

SQLiteはファイルベースの軽量DBとして、単一ファイルで動作します。並行性に制約があります。

#### 挿入スループット
Auto-incrementが最も効率的。UUID v4は性能低下が顕著。

#### CRUDレイテンシ
単一ライター制約のため、並行INSERTで性能が低下。

#### 範囲SELECT分布
B-Treeインデックスを使用。シーケンシャルIDが有利。

#### サイズ比較
ファイルサイズが増加。UUIDのサイズ影響が大きい。

## 最終結論

### 性能比較サマリー

| データベース | ID方式 | 挿入スループット | CRUDレイテンシ | 範囲SELECT | サイズ効率 | 分散性 | 主な用途 |
|--------------|--------|------------------|----------------|------------|------------|--------|----------|
| PostgreSQL | UUID v7 | 高 | 中 | 高 | 低 | あり | 分散システム |
| PostgreSQL | UUID v4 | 低 | 高 | 低 | 低 | あり | 非推奨 |
| MySQL | Auto-increment | 最高 | 低 | 最高 | 最高 | なし | 単一DB |
| MySQL | UUID v7 | 高 | 中 | 高 | 低 | あり | 分散システム |
| MySQL | Snowflake | 高 | 中 | 高 | 高 | あり | 分散システム |
| MySQL | UUID v4 | 低 | 高 | 低 | 低 | あり | 非推奨 |
| Redis | 全方式 | 最高 | 最低 | 中 | 中 | あり | キャッシュ/KVS |
| MongoDB | ObjectId/UUID | 高 | 中 | 中 | 中 | あり | ドキュメントDB |
| SQLite | Auto-increment | 高 | 中 | 高 | 高 | なし | 軽量DB |

- **書き込み・スケール最優先**: Auto-increment（単一DB構成）
- **分散性と性能の両立**: UUID v7（Snowflakeも同等クラス）
- **UUID v4をPKとする選択**: 書き込み・レンジアクセス・サイズ効率の観点で非推奨
- **高速アクセス重視**: Redis（インメモリKVS）
- **柔軟スキーマ**: MongoDB（ドキュメント指向）
- **軽量・単一ファイル**: SQLite（組み込みDB）

### 運用指針
- 単一DB構成ではAuto-incrementを第一候補に
- 分散一意性が要る場合はUUID v7を標準選択肢に
- 既存のUUID v4 PK大規模テーブルは、性能ボトルネックを踏まえ移行検討を推奨
- 高頻度アクセスにはRedisを検討
- スキーマ変更が多い場合はMongoDBを検討
- 軽量・移植性が必要な場合はSQLiteを検討

### 技術的考察
- **B-Treeインデックスの挙動**: UUID v4のランダム性はページ分割を増加させ、断片化を招く。UUID v7の時間順序性はこれを緩和。
- **クラスタ化インデックス（InnoDB）**: MySQLのInnoDBではPKがクラスタ化インデックスとなるため、シーケンシャルIDがI/O効率を高める。
- **インメモリ vs ディスク**: Redisの高速性はメモリベースによるが、永続性は別途考慮。
- **分散システムでの考慮**: UUID v4は生成の簡易性が高いが、性能トレードオフが大きい。UUID v7やSnowflakeは時間順序性を保ちつつ分散性を確保。

このベンチマークは特定の環境での結果であり、実際の運用ではワークロード特性に応じたチューニングが必要です。
